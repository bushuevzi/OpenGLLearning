using System;
using OpenTK;
using OpenTK.Graphics;
using OpenTK.Graphics.OpenGL;
using OpenTK.Input;

namespace OpenGLLearning
{
    /// <summary>
    /// Отрисовка окна с треугольником
    /// </summary>
    public class Game : GameWindow
    {
        // Вершины треугольника. Вершины перечислены в нормальлизованных координатах устройств (NDC -normalized device coordinates)
        // В NDC (0,0,0) -- центр координат
        // Отрицательная X - это левее начала координат
        // Отрицательня Y - это ниже начала координат
        private readonly float[] _vertices =
        {
            -0.5f, -0.5f, 0.0f,
            0.5f, -0.5f, 0.0f,
            0.0f, 0.5f, 0.0f
        };

        #region Дескрипторы
        //----------------------------Дескрипторы------------------------------------------------------------------
        // Это Дескрипторы (объекты содержащие описание) OpenGL объектов.
        // В данном случае дескиптор -- это int отражающий где объект живет в видео карте
        // Это что то вроде указателей. Мы не можем ничего сделать над нами непосредственно, но мы можем
        // Отправить их в функции OpenGL которые в них нуждаются
        
        // Vertex Buffer Object (VBO)
        // Этот буфер используется для отправки пачки вершин в графическую карту за один раз
        private int _vertexBufferObject;
        
        // Vertex Array Object (VAO)
        // Это массив для хранения вершин в виде "макетов", которые содержат в себе информацию о вершинах
        // и примененных к ней атрибутов
        private int _vertexArrayObject;
        //----------------------------Дескрипторы------------------------------------------------------------------
        #endregion

        // Шейдер - программа для выполнения на графической карте
        // и является часть графического конвеера по отрисовке объекта
        private Shader _shader;
        
        public Game(int width, int height, string title) 
            : base(width, height, GraphicsMode.Default, title)
        {
        }

        // Инициализация OpenGL
        protected override void OnLoad(EventArgs e)
        {
            // Цвет бекграунда после того как бы отчистим экран.
            // Цвет задан в нормализованных единица (от 0.0 до 1.0), четвертый параметр - альфаканал
            GL.ClearColor(0.2f, 0.3f, 0.3f,1.0f);
            
            // Создаем буфер для отправки координат нашего объекта в видеокарту в виде одной пачки (одним объектом) за раз 
            _vertexBufferObject = GL.GenBuffer();
            
            // Привязываем буфер который создали к контексту.
            // OpenGL использует одно глобальное состояние, таким образом после того как мы этот привязываем буфер к контексту
            // все последующие вызовы которые будут изменять VBO - будут применять к данному буферу и это будет продол-
            // жаться не будет привязан новый буфер в замен текущему.
            // Первый аргумент это тип буфера который мы привязываем к контексту, в нашем случае VBO -- это ArrayBuffer
            // Второй аргумент это дескриптор нашего буфера VBO
            GL.BindBuffer(BufferTarget.ArrayBuffer, _vertexBufferObject);
            
            // Загружаем информаци о наших вершинах в буфер
            // Аргументы:
            //    В какой буфер данные отправляются
            //    Сколько даных отправляется в буфер
            //    Частота обновления данных в буфере. Существует 3 ванианта отрисовки для которой будут использоваться данные:
            //        StaticDraw: Этот буфер практически никогда не обновляется
            //        DynamicDraw: Этот буфер иногда обновляется
            //        StreamDraw: Этот буфер обновляется каждый кадр.
            GL.BufferData(BufferTarget.ArrayBuffer, _vertices.Length * sizeof(float), _vertices,
                BufferUsageHint.StaticDraw);
            
            // Чтобы преобразовать наш набор вершин в итоговое изображение будет выполнен процес прогона вершин через
            // графический конвеер. При работе этого конвеера OpenGL дает нам большую свободу в определении КАК вершины
            // будут преобразованы в пиксели.
            // Нюансом является то что для этого нам нужны еще 2 программы для этого, которые и называются ШЕЙДЕРАМИ
            // Шейдеры это очень маленькие программы которые живут на GPU. OpenGL использует их для управления конвеером
            // преобразования вершин-в-пиксели
            _shader = new Shader("shader/shader.vert", "shader/shader.frag");

            // Активация шейдеров
            _shader.Use();
            
            // Создаем массив вершин
            // Здесь это излишне НО. Если мы имеем пачку объектов которые используют каждый свой шейдер для отрисовки
            // то может быть невероятно скучным процесс повторной отправки объектов в видеокарту, настройки отобаржения шейдерами
            // при переключения между объектами. Именно поэтому OpenGL требует чтобы был создан Vertex Array Object (VAO)
            // Который хранит макет который был создан через методы VertexAttribPointer/EnableVertexAttribArray 
            // и который может быть повторно создан через один простой вызов функции
            _vertexArrayObject = GL.GenVertexArray();
            // Делаем привязку массива вершин к контексту
            GL.BindVertexArray(_vertexArrayObject);
            
            // Теперь необходимо сделать настройки по которым Вершинный_Шейдер, будет понималь(интерпретировать) данные из
            // буфера Vertex Buffer Object по сути мы должны указать как будут замаплены данные буфера на входные переменные шейдера
            // Чтобы это сделать используем метод VertexAttribPointer
            // Аргументы:
            //    Расположение входных переменных в шейдере. layout(location = 0) строка в вершинном шейдере явно устанавливет это значение в 0
            //    Сколько элементов будет отправлено в переменные шейдера. В данном случае это 3 float для каждой першины
            //    Тип передаваемых переменных
            //    Необходима ли конвертация в NDC
            //    Stride - "Походка" или по другому интенсивность передвижения - сколько байтов между последним элементом одной вершины и 
            //        первым элементом следующей вершины
            //    Offset - сколько байт необходимо пропустить чтоы найти первый элемет первой вершины.
            GL.VertexAttribPointer(0, 3, VertexAttribPointerType.Float, false, 3 * sizeof(float), 0);
            // Включаем переменную layout = 0 в шейдере 
            GL.EnableVertexAttribArray(0);

            // В конечном итоге, мы снова привязываем VBO к контексту, при этом так же автоматически привязывается VAO к контексту и наоборот
            GL.BindBuffer(BufferTarget.ArrayBuffer, _vertexBufferObject);
            
            // Настройка закончена, окончательная отризовка триугольника выполняется в методе OnRenderFrame
            
            base.OnLoad(e);
        }

        protected override void OnRenderFrame(FrameEventArgs e)
        {
            // Очищаем изображение, при этом OpenGL применит цвет который мы указали в настройках GL.ClearColor ранее
            GL.Clear(ClearBufferMask.ColorBufferBit);
            
            //-------------------- Концепция отрисовки --------------------------------
            // Для отрисовки объекта с примененим OpenGL мы дложны обычно:
            // 1) привязать шейдер к контексту
            // TODO: что это под номером 2?
            // 2) установка данных типа uniform для шейдеров - ЧТО ЭТО???????
            // 3) привязать массив вершин VAO к контексту
            // 4) Вызвать метод OpenGL для рендеренга
            //-------------------------------------------------------------------------
            
            // Привязываем шейдер к контексту
            _shader.Use();
            
            // Привязываем массив вершин VAO к контексту
            GL.BindVertexArray(_vertexArrayObject);
            
            // Вызываем метод рендеренга
            // Аргументы:
            //    Тип примитива который представляют соединенные вместе вершины
            //    Начальный индекс вершины с которой начнется рисование
            //    Сколько вершин необходимо отрисовать.
            GL.DrawArrays(PrimitiveType.Triangles, 0, 3);
            
            // Так как у нас используется принцип двойной буферизации при которой в одном буфере строится картинка
            // а вторая выводится на отображение то необходимо обменять значения буферов и вывести подготовленный буфер на оборажение
            Context.SwapBuffers();
            
            base.OnRenderFrame(e);
        }

        protected override void OnResize(EventArgs e)
        {
            GL.Viewport(0,0,Width,Height);
            base.OnResize(e);
        }

        protected override void OnUpdateFrame(FrameEventArgs e)
        {
            var input = Keyboard.GetState();

            if (input.IsKeyDown(Key.Escape))
            {
                Exit();
            }
            
            
            base.OnUpdateFrame(e);
        }

        protected override void OnUnload(EventArgs e)
        {
            GL.BindBuffer(BufferTarget.ArrayBuffer, 0);
            GL.BindVertexArray(0);
            GL.UseProgram(0);

            // Delete all the resources.
            GL.DeleteBuffer(_vertexBufferObject);
            GL.DeleteVertexArray(_vertexArrayObject);

            _shader.Dispose();
            
            base.OnUnload(e);
        }
    }
}